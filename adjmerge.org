#+TITLE: Transition system 1: Merge Two Adjacent Sublists (M1) 

In this system we merge two sublists in a given list of numbers.

* Sublist Primitive

Given a list =a= and two non-negative integers =i= and =j=, =sublist i
j a= returns a list =b= such that:

for all *x* if *i < = x < j* then  *b[x - i] = a[x]*.

Example:

=sublist 1 3 [10, 40, 5, 3, 7]= ==> =[40, 5]=

=sublist 1 2 [10, 40, 5, 3, 7]= ==> =[40]=

=sublist 0 0 [10, 40, 5, 3, 7]= ==> =[]=


#+NAME: sublist
#+BEGIN_SRC elm
sublist : Int -> Int -> List Int -> List Int
sublist i j l =
    l |> List.indexedMap (\idx val -> (idx, val))
      |> List.filter (\(idx, val) -> idx >= i && idx < j)
      |> List.map (\(idx, val) -> val)
#+END_SRC


* System Definition






** State Space
The state space of this system consists of the following:

- List of numbers (lst)
- Set of selected indices (selections)

The =selections= set consists of non-negative integers that represent
indices of the list =lst=.

The =selections= set can be empty and it cannot have more than 3
elements.  We use this set of indices to select the sublists from
=lst= that we want to merge.  Merge operation requires two lists, and
one sublist operation requires two indices, how can we achieve this
using only 3 indices?

We need only three indices because in this system we are going to only
merge adjacent sublists.

#+NAME: model
#+BEGIN_SRC elm
type alias Model = 
    { lst : List Int
    , selections : Set Int
    }
#+END_SRC

#+NAME: init
#+BEGIN_SRC elm
init : Model
init = 
    { lst = [100, 50, 60, 30, 20, 70]
    , selections = Set.fromList []
    }
#+END_SRC

** Inputs
This system can take the following inputs:

- Select i :: add =i= to the set of selected indices.

- Deselect i :: remove =i= from the set of selected indices.

- Merge :: if there are three indices (i, j, k) in the selections set,
           such that /i <= j <= k/ then merge =sublist i j lst= and
           =sublist j k lst= and replace lst[i,k] with the result.
           Otherwise do nothing.

#+NAME: inputs
#+BEGIN_SRC elm
type Msg = Select Int 
         | Deselect Int
         | Merge
#+END_SRC


** Transition Function

Each input has an associated transition function.  In this section we
define the transition functions for each input and a function that
maps each input to the corresponding transition function.

*** Mapping inputs to transition functions
The function =update msg model= maps each input define in the =Msg=
type to a transition function.

#+NAME: update
#+BEGIN_SRC elm
update : Msg -> Model -> Model
update msg model =
    case msg of
        Select i -> select i model
        Deselect j -> deselect j model
        Merge -> merge model
#+END_SRC


*** Select

[[file:img/ms-modalities.png]]

The function =select i model= defines the transition function for the
input =Select i=.  This function adds i to the set of selected
indices (=selections=).

#+NAME: select
#+BEGIN_SRC elm
addIndex : Int -> Set Int -> Set Int
addIndex i selections =
    if Set.size selections == 3 then 
        selections 
    else Set.insert i selections


select : Int -> Model -> Model
select i model =
    {model | selections = model.selections |> addIndex i}
#+END_SRC

*** Deselect

[[file:img/ms-deselect.png][file:img/ms-deselect.png]]

The function =deselect i model= removes i from the set of selected
indices.

#+NAME: deselect
#+BEGIN_SRC elm
removeIndex : Int -> Set Int -> Set Int
removeIndex i selections =
    Set.remove i selections


deselect : Int -> Model -> Model
deselect i model =
    {model | selections = model.selections |> removeIndex i}
#+END_SRC


*** Merge

[[file:img/ms-merge-action.png]]

The function =merge model= maps to the =Merge= input.  If the
selections set contains three indices, merge function merges the
sublists defined by the selected indices.

#+NAME: merge
#+BEGIN_SRC elm
mergeSublistsAt : Int -> Int -> Int -> List Int -> List Int
mergeSublistsAt i j k lst =
    List.concat [ (sublist 0 i lst)
                , C.merge (sublist i j lst) (sublist j k lst)
                , (sublist k (List.length lst) lst)
                ]

merge : Model -> Model
merge model =
    let {lst, selections} = model
        indices = selections |> Set.toList |> List.sort
    in
        case indices of
            [i, j, k] -> 
                { model | lst = lst |> mergeSublistsAt i j k
                        , selections = Set.empty
                }
            _ -> model
#+END_SRC


** Outputs

#+NAME: view
#+BEGIN_SRC elm
gridLine : Int -> Bool -> Html Msg
gridLine position isSelected = 
    Html.div
        [ HA.style "background" (if isSelected then "#FF5722" else "#B2EBF2") 
        , HA.style "padding" "0.5em"
        , HE.onClick (if isSelected then (Deselect position) else (Select position))
        , HA.style "display" "flex"
        , HA.style "align-items" "center"
        ]
        [
        ]


selected : Int -> Set Int -> Bool
selected i selections =
    Set.member i selections


itemview : Int -> Int -> Int -> Set Int -> Html Msg
itemview val index length indices =
    if index == length - 1 then
        Html.div
            [ HA.style "display" "flex"
            , 
            ]
            [ gridLine index <| selected index indices
            , Html.div
                [ HA.style "border" "1px solid"
                , HA.style "margin" "1em"
                , HA.style "display" "flex"
                , HA.style "flex-direction" "column"
                , HA.style "align-items" "center"
                ]
                [ Html.span 
                    [ HA.style "border-bottom" "1px solid"
                    , HA.style "padding" "0.5em"
                    ] 
                    [Html.text <| String.fromInt val]
                , Html.span 
                    [] [Html.text <| String.fromInt index]
                ]
            , gridLine (index + 1) <| selected (index + 1) indices
            ]
    else
        Html.div
            [ HA.style "display" "flex"
            ]
            [ gridLine index <| selected index indices
            , Html.div
                [ HA.style "border" "1px solid"
                , HA.style "margin" "1em"
                , HA.style "display" "flex"
                , HA.style "flex-direction" "column"
                , HA.style "align-items" "center"
                ]
                [ Html.span 
                    [ HA.style "border-bottom" "1px solid"
                    , HA.style "padding" "0.5em"
                    ] 
                    [Html.text <| String.fromInt val]
                , Html.span 
                    [] [Html.text <| String.fromInt index]
                ]
            ]

view model = 
    Html.div
        [ HA.style "margin" "100px 100px"
        ]
        [ Html.div [HA.style "display" "flex"]
            (List.indexedMap
            (\ i v ->
                itemview v i (List.length model.lst) model.selections
            ) model.lst)
        , Html.div []
            [
            ]
        , Html.button 
            [ HE.onClick Merge
            ]
            [Html.text "merge"]
        ]
#+END_SRC


* Tangle

#+BEGIN_SRC elm :noweb yes :tangle src/MS/M1.elm
module MS.M1 exposing (..)

import Set exposing (Set)
import LMerge as C
import Browser
import Array exposing (Array)
import Random
import Random.Array as RA
import Html exposing (Html)
import Html.Attributes as HA
import Html.Events as HE
--import List.Extra as LE

<<sublist>>

-- state space

<<model>>
<<init>>

-- inputs

<<inputs>>

-- input to transition functions map

<<update>>

-- transition functions for each input

<<select>>
<<deselect>>
<<merge>>


<<view>>
main = Browser.sandbox {init = init, view = view, update = update}
#+END_SRC
